	/// https://medium.com/quick-code/learning-solidity-with-a-simple-fundraising-smart-contract-2fad8b1d8b73
  
  // https://medium.com/@adeyemitoluhi
  
  contract BonusScheme {
	
  
  // Defining a struct for an order request 
  struct Order {
    address employee;
		address partner;
		address item;
		uint quantity;
		uint price;
    bool init;
    bool completed;
  }
  
  struct Employee {
		address emp_addr;
    bool registered;
	}

	struct Partner {
		address parner_addr;
    bool registered;
	}

	struct Reciept {
		uint orderno;
	}
  
  struct Item {
		address item_addr;
    bools exists;
    address partner
    uint price;
    uint quantity;
	}


  uint private ordersequence;
  uint private partnersequence;
  uint private itemsequence;

	// Storage variables 
  mapping (address => uint) wallets; 																													// HOLDS EACH EMPLOYEES WALLET BALANCE (ADDRESS USED TO REFER TO THE EMPLOYEE, UINT THEIR BALANCE)
  mapping (uint => Order) orders;
	mapping (uint => Reciept) reciepts; 
	mapping (uint => Partner) partners;
	mapping (address => Employee) employees;
  mapping (address => Item[]) 																																// THE ADDRESS WILL BE THE ADDRESS OF THE PARTNER
	mapping (uint => Item) items;

  address public company;            
  address public employeeAddr;
  
  event OrderPlaced(uint orderno, address employee, address item, uint total);
  event RecieptSent(uint orderno);
  event OrderCancelled(uint orderno);
  event EmployeePaid(address employee, uint amount);
  event EmployeeRegistered(address employee);
  event PaymentSent(address employee, uint orderno, uint amount);
  
  
  // The constructor 
	function BonusScheme(address _empAddr) public {
		company = msg.sender;																																			// THE COMPANY IS THE OWNER OF THE CONTRACT ... OR SHOULD THE EMPLOYEE BE THE CONTR
		employeeAddr = _empAddr;
	}
  
  
	function placeOrder(address _employee, address _item) public payable employeeOnly checkItemAvailiable checkFundsAvailiable returns(bool) {    

    // IF THE EMPLOYEE DOES NOT HAVE AN ACCOUNT ON THE BONUS SCHEME, CREATE AN ACCOUNT FOR THEM BY ADDING THEM TO THE EMPLOYEES MAPPING
    // Only the company is able to register new employees.
    if(!employees[_employee].registered) {
    	// registerEmployee(_employee);
      revert(â€˜Employee not registered on bonus scheme.â€™);
    }
    
    ordersequence++;
    
    OrderPlaced(ordersequence, _employee, _item, items[_item].price);
    sendReciept(ordersequence);
    RecieptSent(ordersequence);
    pay(_employee, ordersequence, items[_item].price);
    
    return true;
  }
  
  function sendReciept(uint _orderno) {
  	
  	  
  }
  
  
  function pay(address _employee, uint _orderno, uint amount) employeeOnly checkFundsAvailiable {
  	require(orders[_orderno].init);
  	wallets[_employee] -= amount;
    PaymentSent(_employee, _orderno, amount)
  }
  
  function reject() {
  
  }
  
  // AD HOc REWARD PAYMENT
  function payEmployee(address _employee, uint _amount) companyOnly {
    
    require(_amount > 0);
    
    if(employees[_employee].registered) {
      wallets[_employee] += _amount;    
    } else {
    	registerEmployees(_employee);
      payEmployee(_employee, _amount);
    }
    
    EmployeePaid(_employee, _amount);
  }
  
  function registerEmployee(address _employee) companyOnly {
    employees[_employee] = Employee(_employee, true);  
  }
  
  function addPartner(address _partner) companyOnly {
    if(!partners[_partner].registered) {
      partners[_partner] = Partner(_partner, true);
    }
  }
  
  function addItem(address _item, address _partner, uint _price, uint _quantity) companyOnly {      
    if(!items[_item].exists) {
      items[_item] = Item(_item, true, _partner, _price, _quantity);
    } else {
    	items[_item].quantity += _quantity;
    }
  }
  
  // TODO
  function removeEmployee(address _employee) companyOnly {
  	delete user[someAddress];
  }
  
  // TODO
  function removePartner(address _employee) isPartner companyOnly {
  	delete user[someAddress];
  }
  
  // TODO
  function removeItem(address _employee) companyOnly {
  	delete user[someAddress];
  }
  
  ///////////////
  // MODIFIERS //
  ///////////////
  
  modifier companyOnly {
		// A function which can only be executed by the company
  	require(msg.sender == company);
   _;
	}
	
  modifier employeeOnly {
    // A function which can only be executed by an employee
  	require(msg.sender == employeeAddr);
   _;
	}
  
  modifier checkItemAvailiable(address _item) {
   require(items[_item].exists && items[_item].quantity > 0);
   _;
	}

  modifier checkFundsAvailiable(address _employee, address _item) {
   require(wallets[_employee] >= items[_item].price);
   _;
	}

  modifier isPartner(address _partner) {
   require(partners[_partner].registered);
   _;
	}

}

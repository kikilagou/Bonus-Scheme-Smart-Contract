///// https://medium.com/quick-code/learning-solidity-with-a-simple-fundraising-smart-contract-2fad8b1d8b73
  
  pragma solidity ^0.5.1;
  // https://medium.com/@adeyemitoluhi
  contract BonusScheme {
      
  /* Bonus Scheme internals */
  address public company;            
  address public employeeAddr;
  
  // Defining a struct for an order request 
  struct Order {
    uint order_id;
    address employee;
	address partner;
	uint[] items;
	// uint quantity;
	uint price;
    bool init;
    bool completed;
  }
  
  struct Employee {
	address emp_addr;
	string emp_name;
	// uint balance;  // I will go with a mapping to hold the wallets instead
	ShoppingCart cart;
    bool registered;
	}

  struct ShoppingCart {
    uint[] items;
    uint total;
  }

  struct Partner {
	address parner_addr;
	string parner_name;
	//uint[] items;
	mapping (uint => uint) items;
    bool registered;
	}

  struct Reciept {
	uint orderno;
	address emp_addr;
	}
  
  struct Item {
	// address item_addr;
	uint item_id;
	string name;
	bytes32 description;
    bool exists;
    address partner;
    uint price;
    uint quantity;
	}

  uint private ordersequence;
//  uint private partnersequence;
  uint private itemsequence;

	// Storage variables 
  mapping (address => uint) wallets; 																													// HOLDS EACH EMPLOYEES WALLET BALANCE (ADDRESS USED TO REFER TO THE EMPLOYEE, UINT THEIR BALANCE)
  mapping (uint => Order) orders;
  mapping (address => Partner) partners;
  mapping (address => Employee) employees;
  mapping (uint => Item) items;
  //mapping (address => Item[]) 																															// THE ADDRESS WILL BE THE ADDRESS OF THE PARTNER
  // mapping (address => Reciept) reciepts; 

  event EmployeeRegistered(address employee);
  event EmployeeRegistrationFailed(address employee);
  event EmployeeRemovedFromRegister(address employee);
  event EmployeeRemovalFailed(address employee);
  event EmployeePaid(address employee, uint amount);
  
  event ItemRegistered(uint item_id); 
  event ItemRemovedFromRegister(uint item_id);
  event ItemRegistrationFailed(uint item_id);
  event ItemRemovalFailed(uint item_id);
  event ItemIncremented(uint item_id);
  event ItemIncrementFailed(uint item_id);
  
  event PartnerRegistered(address partner);
  event PartnerRegistrationFailed(address partner);
  event PartnerRemovedFromRegister(address partner);
  event PartnerRemovalFailed(address partner);
  
  event ItemInsertedToCart(address employee, uint item_id, uint item_price, uint cart_total);
  event ItemInsertionToCartFailed(address employee, uint item_id);
  event ItemRemovedFromCart(address employee, uint item_id);
  event OrderPlaced(address employee, uint order_total);
  event OrderFailed(address employee, uint employee_balance, uint cart_total);
  event CartEmptied(address employee);


  // event OrderPlaced(uint orderno, address employee, address item, uint total);
  // event RecieptSent(uint orderno);
  // event OrderCancelled(uint orderno);
  // event PaymentSent(address employee, uint orderno, uint amount);
  
  
  // The constructor 
	constructor(address _empAddr) public {
		company = msg.sender;																																			// THE COMPANY IS THE OWNER OF THE CONTRACT ... OR SHOULD THE EMPLOYEE BE THE CONTR
		employeeAddr = _empAddr;
	}
	
    // function registerItem(address _item, address _partner, uint _price, uint _quantity) companyOnly public {      
    //     if(!items[_item].exists) {
    //       items[_item] = Item(_item, true, _partner, _price, _quantity);
    //     } else {
    //     	items[_item].quantity += _quantity;
    //     }
    //   }
    
    /**
          @notice Register a new item. In order to register an item, the company that provides it must already be a partner otherwise product registration fails. Only the company can register a new item.
          @param item_name - item name
          @param description - item description
          @param exists - boolean to signify item is registered
          @param partner_addr - address of partner that supplied the item
          @param price - item price
          @param quantity - the number of this item that exists
          @return success

    */
    function registerItem(string _item_name, bytes32 _description, address _partner_addr, uint _price, uint _quantity) companyOnly, isPartner(_partner_addr) returns (bool success) {
        
        itemsequence++;
        var item = Item(itemsequence, _item_name, _description, _exists, _partner_addr, _price, _quantity);
        
        // Check that the item is not already registered, if it is fail. 
        if (!items[itemsequence].exists && checkItemIsValid(item)) {
            items[itemsequence] = item;
            ItemRegistered(itemsequence);
            
            return true;
        }
        ItemRegistrationFailed(itemsequence);
        
        return false;
    }
    
     /**
          @notice Checks an item is valid. 
          @param item - Item struct
          @return valid
    */
    function checkItemIsValid(Item item) private returns (bool valid) {
       return (item.price > 0);
    }
    
    /**
          @notice Increment amount of existing item. Only the company can do this. Item must already be registered.
          @param item_id - item ID
          @param amount - number of item added
          @return success

    */
    function incrementItemInventory(uint item_id, uint amount) companyOnly, checkItemRegistered(item_id) returns (bool success) {
        
            items[item_id].quantity += amount;
            ItemIncremented(item_id);
            
            return true;
    }
    
     /**
          @notice Removes an item from the list of availiable items. Only a company can do this.
          @param _item_id - item id
          @return success
    */
    function removeItemFromRegister(uint _item_id) companyOnly public returns (bool success)  {
        
        Item item = items[_item_id];
        Partner partner = item.partner;
        
        if (item.item_id == _item_id && item.exists) {
            delete items[_item_id];
            delete partner.items[_item_id];
            ItemRemovedFromRegister(_item_id);
    
            return true;
      }
      
      ItemRemovalFailed(_item_id);

      return false;
    }    
    

    /**
          @notice Registers a new employee of the bonus scheme. Only the company can do this.
          @param _address new employee's address
          @param _name employee's name
          @param _balance employee's account balance
          @return success
    */
    function registerEmployee(address _address, string _emp_name, uint _balance) companyOnly public returns (bool success) {
        
        if (_address != address(0)) {
            ShoppingCart cart = ShoppingCart(new uint[](0), 0);
            Employee employee = Employee(_address, _emp_name, cart, true);
            
            // create employee wallet
            wallets[_address] = _balance;
       
            EmployeeRegistered(_address);
            return true;
            }
            
        EmployeeRegistrationFailed(_address);
        return false;
    }
    
    
    















	function placeOrder(address _employee, address _item) public payable employeeOnly checkItemAvailiable(_item) checkFundsAvailiable(_employee, _item) returns(bool) {    

    // IF THE EMPLOYEE DOES NOT HAVE AN ACCOUNT ON THE BONUS SCHEME, CREATE AN ACCOUNT FOR THEM BY ADDING THEM TO THE EMPLOYEES MAPPING
    // Only the company is able to register new employees.
    if(!employees[_employee].registered) {
    	// registerEmployee(_employee);
      revert("Employee not registered on bonus scheme.");
    }
    
    require(items[_item].exists);
    
    ordersequence++;
 //   address amount = items[_item].price;
    
    
    emit OrderPlaced(ordersequence, _employee, _item, items[_item].price);
   // sendReciept(ordersequence);
    emit RecieptSent(ordersequence);
    pay(_employee, ordersequence, _item);
    
    return true;
  }
  
  // function sendReciept(uint _orderno) {}
  
  
  function pay(address _employee, uint _orderno, address _item) employeeOnly checkFundsAvailiable(_employee, _item) public {
  	require(orders[_orderno].init);
  	wallets[_employee] -= items[_item].price;
    emit  PaymentSent(_employee, _orderno, items[_item].price);
  }
  
  // function reject() {}
  
  // AD HOc REWARD PAYMENT
  function payEmployee(address _employee, uint _amount) companyOnly public {
    
    require(_amount > 0);
    
    if(employees[_employee].registered) {
      wallets[_employee] += _amount;    
    } else {
    	registerEmployee(_employee);
      payEmployee(_employee, _amount);
    }
    
    emit EmployeePaid(_employee, _amount);
  }
  

  
  function addPartner(address _partner) companyOnly public {
    if(!partners[_partner].registered) {
      partners[_partner] = Partner(_partner, true);
    }
  }
  
  
  
  // TODO
  function removeEmployee(address _employee) companyOnly employeeExists(_employee) public {
  	delete employees[_employee];
  }
  
  // TODO
  function removePartner(address _partner) isPartner(_partner) companyOnly public {
  	delete partners[_partner];
  }


  ///////////////
  // MODIFIERS //
  ///////////////
  
  modifier companyOnly {
		// A function which can only be executed by the company
  	require(msg.sender == company);
   _;
	}
	
  modifier employeeOnly {
    // A function which can only be executed by an employee
  	require(msg.sender == employeeAddr);
   _;
	}
  
  modifier checkItemAvailiable(uint _item) {
   require(items[_item].exists && items[_item].quantity > 0);
   _;
	}

  modifier checkFundsAvailiable(address _employee, uint _item) {
   require(wallets[_employee] >= items[_item].price);
   _;
	}

  modifier isPartner(address _partner) {
   require(partners[_partner].registered);
   _;
	}
	
  modifier employeeExists(address _employee) {
   require(employees[_employee].registered);
   _;
	}
	
  modifier checkItemRegistered(uint _item) returns(bool success) {
   require(items[_item].exists);
   if(!items[_item].exists) {
    emit ItemIncrementFailed(_item);
    return false;
   }
    _;
    }


}

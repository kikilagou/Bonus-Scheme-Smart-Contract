///// https://medium.com/quick-code/learning-solidity-with-a-simple-fundraising-smart-contract-2fad8b1d8b73
  
  pragma solidity ^0.5.1;
  // https://medium.com/@adeyemitoluhi
  contract BonusScheme {
      
  /* Bonus Scheme internals */
  address public company;            
  address public employeeAddr;
  
  // Defining a struct for an order request 
  struct Order {
    uint order_id;
    address employee;
	uint partner_id;
	uint[] items;
	// uint quantity;
	uint price;
    bool init;
    bool completed;
  }
  
  struct Employee {
	address emp_addr;
	string emp_name;
	// uint balance;  // I will go with a mapping to hold the wallets instead
	ShoppingCart cart;
    bool registered;
	}

  struct ShoppingCart {
    uint[] items;
    uint total;
  }

  struct Partner {
	unit parner_id;
	string parner_name;
	// holds item ids
	uint[] items;
	// item id - number
//	mapping (uint => uint) items;
    bool registered;
	}

  struct Reciept {
	uint orderno;
	address emp_addr;
	}
  
  struct Item {
	// address item_addr;
	uint item_id;
	string name;
	bytes32 description;
    bool exists;
    uint partner_id;
    uint price;
    uint quantity;
	}

  uint private ordersequence;
  uint private itemsequence;
  uint private partnersequence;

	// Storage variables 
  mapping (address => uint) wallets; 																													// HOLDS EACH EMPLOYEES WALLET BALANCE (ADDRESS USED TO REFER TO THE EMPLOYEE, UINT THEIR BALANCE)
  mapping (uint => Order) orders;
  mapping (uint => Partner) partners;
  mapping (address => Employee) employees;
  mapping (uint => Item) items;
  //mapping (address => Item[]) 																															// THE ADDRESS WILL BE THE ADDRESS OF THE PARTNER
  // mapping (address => Reciept) reciepts; 

  event EmployeeRegistered(address employee);
  event EmployeeRegistrationFailed(address employee);
  event EmployeeRemovedFromRegister(address employee);
  event EmployeeRemovalFailed(address employee);
  event EmployeePaid(address employee, uint amount);
  event EmployeePaymentFailed(address employee);
  
  event ItemRegistered(uint item_id); 
  event ItemRemovedFromRegister(uint item_id);
  event ItemRegistrationFailed(uint item_id);
  event ItemRemovalFailed(uint item_id);
  event ItemIncremented(uint item_id);
  event ItemIncrementFailed(uint item_id);
  
  event PartnerRegistered(uint partner_id);
  event PartnerRegistrationFailed(uint partner_id);
  event PartnerRemovedFromRegister(uint partner_id);
  event PartnerRemovalFailed(address partner_id);
  
  event ItemInsertedToCart(address employee, uint item_id, uint item_price, uint cart_total);
  event ItemInsertionToCartFailed(address employee, uint item_id);
  event ItemRemovedFromCart(address employee, uint item_id);
  event OrderPlaced(address employee, uint order_total);
  event OrderFailed(address employee, uint employee_balance, uint cart_total);
  event CartEmptied(address employee);


  // event OrderPlaced(uint orderno, address employee, address item, uint total);
  // event RecieptSent(uint orderno);
  // event OrderCancelled(uint orderno);
  // event PaymentSent(address employee, uint orderno, uint amount);
  
  
  // The constructor 
	constructor(address _empAddr) public {
		company = msg.sender;																																			// THE COMPANY IS THE OWNER OF THE CONTRACT ... OR SHOULD THE EMPLOYEE BE THE CONTR
		employeeAddr = _empAddr;
	}
    
    /**
          @notice Register a new item. In order to register an item, the company that provides it must already be a partner otherwise product registration fails. Only the company can register a new item.
          @param item_name - item name
          @param description - item description
          @param exists - boolean to signify item is registered
          @param partner_addr - address of partner that supplied the item
          @param price - item price
          @param quantity - the number of this item that exists
          @return success

    */
    function registerItem(string _item_name, bytes32 _description, uint _partner_id, uint _price, uint _quantity) companyOnly isPartner(_partner_id) returns (bool success) {
        
        itemsequence++;
        var item = Item(itemsequence, _item_name, _description, _exists, _partner_id, _price, _quantity);
        
        // Check that the item is not already registered, if it is fail. 
        if (!items[itemsequence].exists && checkItemIsValid(item)) {
            items[itemsequence] = item;
            ItemRegistered(itemsequence);
            
            return true;
        }
        ItemRegistrationFailed(itemsequence);
        
        return false;
    }
    
     /**
          @notice Checks an item is valid. 
          @param item - Item struct
          @return valid
    */
    function checkItemIsValid(Item item) private returns (bool valid) {
       return (item.price > 0);
    }
    
    /**
          @notice Increment amount of existing item. Only the company can do this. Item must already be registered.
          @param item_id - item ID
          @param amount - number of item added
          @return success

    */
    function incrementItemInventory(uint item_id, uint amount) companyOnly, checkItemRegistered(item_id) returns (bool success) {
            
            Partner partner = items[_item_id].partner;
            
            items[item_id].quantity += amount;
            partner.items[_item_id].quantity += amount;
            
            ItemIncremented(item_id);
            
            return true;
    }
    
     /**
          @notice Removes an item from the list of availiable items. Only a company can do this.
          @param _item_id - item id
          @return success
    */
    function removeItemFromRegister(uint _item_id) companyOnly public returns (bool success)  {
        
        Item item = items[_item_id];
        Partner partner = item.partner_id;
        
        if (item.item_id == _item_id && item.exists) {
            delete items[_item_id];
            
            
            // iterate through and delete the item from the partner's listing of items
            for(i = 0; i < partner.items.length; i++) {
                if(partner.items[i] == _item_id) {
                    // remove the item from the partner array // BUT THIS LEAVES A GAP
                    //delete array[index];
                    uint index = i;
                }
            }
            
            // manually get rid of the gap left by removing the item in the partner's listing of item 
            if (index >= array.length) return false;
            for (uint i = index; i< partner.items.length-1; i++){
                partner.items[i] = partner.items[i+1];
            }
            partner.items.length--;
            
            ItemRemovedFromRegister(_item_id);
    
            return true;
      }
      
      ItemRemovalFailed(_item_id);

      return false;
    }    
    
    /**
          @notice Registers a new employee of the bonus scheme. Only the company can do this.
          @param _address new employee's address
          @param _name employee's name
          @param _balance employee's account balance
          @return success
    */
    function registerEmployee(address _address, string _emp_name, uint _balance) companyOnly public returns (bool success) {
        
        if (_address != address(0)) {
            ShoppingCart cart = ShoppingCart(new uint[](0), 0);
            Employee employee = Employee(_address, _emp_name, cart, true);
            
            // create employee wallet
            wallets[_address] = _balance;
       
            EmployeeRegistered(_address);
            return true;
            }
            
        EmployeeRegistrationFailed(_address);
        return false;
    }
    
    /**
        @notice Removes an employee from the bonus scheme, only a company can do this
        @param _employee employee's address
        @return success
    */
    function removeEmployee(address _employee) companyOnly employeeExists(_employee) public returns (bool success) {
        
        Employee employee = employees[_employee];
        
        if (employee.emp_addr != address(0)) {
            delete employees[_employee];
            EmployeeRemovedFromRegister(_employee);
            return true;
      }
      EmployeeRemovalFailed(_employee);
      return false;
    }
    
    
    /**
          @notice Registers a new partner of the bonus scheme. Only the company can do this.
          @param _partner_name partner's name
          @param _items partner's item offerings
          @return success
    */
    function registerPartner(string _partner_name, mapping (uint => uint) _items) companyOnly public returns (bool success) {

        require(!partners[partnersequence].registered);
        
        partnersequence++;
        var partner = Partner(partnersequence, _partner_name, _items, true);
        
        if (!partners[partnersequence].registered)) {
            partners[partnersequence] = partner;
            PartnerRegistered(partnersequence);
            
            return true;
        }
        PartnerRegistrationFailed(partnersequence);
        
        return false;
    }
    
    /**
        @notice Removes a partner company from the bonus scheme, only a company can do this
        @param _partner_id partners's id
        @return success
    */
    function removePartner(address _partner_id) companyOnly isPartner(_partner_id) public returns (bool success) {
        
        Partner partner = partners[_partner_id];
        uint arrayLength = partner.items.length;
                
        if (partner.partner_id == _partner_id && partner.registered) {
            delete partners[_partner_id];
        
        // delete items with that partner id
        for (uint i = 0; i < arrayLength; i++) {
            delete items[partner.items[i]]
        }
            
        PartnerRemovedFromRegister(_partner_id);
        return true;
      }
      
      PartnerRemovalFailed(_partner_id);
      return false;
    }    

    /**
        @notice Ad hoc reward payment into employee's balance. Done when company adds reward to employees account.
        @param _employee employee's id
        @param _amount amount to be added to employee's account
        @return success
    */
    function payEmployee(address _employee, uint _amount) companyOnly employeeExists public returns (bool success) {
    
        require(_amount > 0);
        
        if(employees[_employee].registered) {
          wallets[_employee] += _amount;
          
          emit EmployeePaid(_employee, _amount);
          return true;
          
        }
        
        emit EmployeePaymentFailed(_employee);
        return false;
    }
    
    /**
        @notice Inserts an item into an employee's shopping cart.
        This function returns a boolean and the position of the
        inserted product.
        The positional information can later be used to directly reference
        the product within the mapping. Solidity mappings aren't interable.
        @param _item_id item ID
        @return (success, index_in_prod_map)

    */
    function addItemToCart(uint _item_id) returns (bool success, uint index_in_prod_map) {
        Employee employee = employees[msg.sender];
        Item item = items[_item_id];
        uint prods_prev_len = employee.cart.items.length;
        employee.cart.items.push(item.item_id);
        uint curr_total = employee.cart.total;
        employee.cart.total = safeAdd(curr_total, item.price);
        
        if (employee.cart.items.length > prods_prev_len) {

          ItemInsertedToCart(msg.sender, _item_id, item.price, employee.cart.total);

          return (true, employee.cart.items.length - 1);
        }
        
        ItemInsertionToCartFailed(msg.sender, _item_id);

        return (false, 0);
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    















	function placeOrder(address _employee, address _item) public payable employeeOnly checkItemAvailiable(_item) checkFundsAvailiable(_employee, _item) returns(bool) {    

    // IF THE EMPLOYEE DOES NOT HAVE AN ACCOUNT ON THE BONUS SCHEME, CREATE AN ACCOUNT FOR THEM BY ADDING THEM TO THE EMPLOYEES MAPPING
    // Only the company is able to register new employees.
    if(!employees[_employee].registered) {
    	// registerEmployee(_employee);
      revert("Employee not registered on bonus scheme.");
    }
    
    require(items[_item].exists);
    
    ordersequence++;
 //   address amount = items[_item].price;
    
    
    emit OrderPlaced(ordersequence, _employee, _item, items[_item].price);
   // sendReciept(ordersequence);
    emit RecieptSent(ordersequence);
    pay(_employee, ordersequence, _item);
    
    return true;
  }
  
  // function sendReciept(uint _orderno) {}
  
  
  function pay(address _employee, uint _orderno, address _item) employeeOnly checkFundsAvailiable(_employee, _item) public {
  	require(orders[_orderno].init);
  	wallets[_employee] -= items[_item].price;
    emit  PaymentSent(_employee, _orderno, items[_item].price);
  }


  ///////////////
  // MODIFIERS //
  ///////////////
  
  modifier companyOnly {
		// A function which can only be executed by the company
  	require(msg.sender == company);
   _;
	}
	
  modifier employeeOnly {
    // A function which can only be executed by an employee
  	require(msg.sender == employeeAddr);
   _;
	}
  
  modifier checkItemAvailiable(uint _item) {
   require(items[_item].exists && items[_item].quantity > 0);
   _;
	}

  modifier checkFundsAvailiable(address _employee, uint _item) {
   require(wallets[_employee] >= items[_item].price);
   _;
	}

  modifier isPartner(uint _partner) {
   require(partners[_partner].registered);
   _;
	}
	
  modifier employeeExists(address _employee) {
   require(employees[_employee].registered);
   _;
	}
	
  modifier checkItemRegistered(uint _item) returns(bool success) {
   require(items[_item].exists);
   if(!items[_item].exists) {
    emit ItemIncrementFailed(_item);
    return false;
   }
    _;
    }


}
